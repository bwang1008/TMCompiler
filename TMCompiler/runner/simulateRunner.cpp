/**
 * Given the name of a JSON file generated by the compile program,
 * read in the Multi-Tape Turing Machine and simulate for a number of steps
 */

#include <exception>		// std::exception
#include <iostream>			// std::cout, std::endl
#include <fstream>			// std::ifstream
#include <stdexcept>		// std::invalid_argument
#include <string>			// std::string, std::stoi
#include <unordered_map>	// std::unordered_map
#include <utility>			// std::pair, std::get
#include <vector>			// std::vector

#include "TMCompiler/tm_definition/multi_tape_turing_machine.hpp"
#include "TMCompiler/utils/helper.hpp"
#include "TMCompiler/utils/json.hpp"

struct CommandLineParser {
	struct CommandOption {
		std::vector<std::string> aliases;
		bool hasParam;
		std::string value;
		std::string defaultValue;
		std::string description;

		CommandOption(std::vector<std::string> aliases, bool hasParam, std::string value, std::string description) : aliases(), hasParam(hasParam), value(value), defaultValue(value), description(description) {
			for(std::string alias : aliases) {
				this->aliases.push_back(alias);
			}
		}
	};
	
	std::string programName;
	std::vector<CommandOption> options;
	std::unordered_map<std::string, size_t> findOptionIndex;

	void addOption(std::vector<std::string> aliases, bool hasParam, std::string value, std::string description) {
		options.emplace_back(aliases, hasParam, value, description);

		for(std::string alias : aliases) {
			findOptionIndex[alias] = options.size() - 1;
		}
	}

	std::vector<std::string> parseCommandLine(const int argc, const char* argv[]) {
		const std::vector<std::string> args(argv + 1, argv + argc);
		size_t start = 0;
		std::vector<std::string> unprocessed;

		while(start < args.size()) {
			std::string arg = args[start];
			
			if(arg.size() > 2 && arg.substr(0, 2) == "--") {
				size_t equalIndex = arg.find("=");
				if(equalIndex != std::string::npos) {
					std::string name = arg.substr(2, equalIndex - 2);
					std::string value = arg.substr(equalIndex + 1, arg.size() - equalIndex - 1);
					if(options[findOptionIndex[name]].hasParam) {
						options[findOptionIndex[name]].value = value;
					}
					else {
						throw std::invalid_argument("Option " + name + " has no parameters");
					}
				}
				else {
					std::string name = arg.substr(2, arg.size() - 2);
					if(options[findOptionIndex[name]].hasParam) {
						throw std::invalid_argument("Option " + name + " requires a parameter");
					}

					options[findOptionIndex[name]].value = "true";
				}

				start += 1;
			}
			else if(arg.size() > 1 && arg.substr(0, 1) == "-") {
				// one-letter command
				std::string name = arg.substr(1, 1);

				if(options[findOptionIndex[name]].hasParam) {
					std::string value = arg.substr(2, arg.size() - 2);
					if(value.size() == 0) {
						if(start + 1 < args.size()) {
							value = args[start + 1];
							start += 2;
						}
						else {
							throw std::invalid_argument("Parameter for option " + name + " not specified");
						}
					}
					else {
						start += 1;
					}

					options[findOptionIndex[name]].value = value;
				}
				else {
					// no parameter required
					if(arg.size() > 2) {
						throw std::invalid_argument(arg + " : parameter with one dash should be followed only by one letter");
					}

					options[findOptionIndex[name]].value = "true";
					start += 1;
				}
				
			}
			else {
				unprocessed.push_back(arg);
				start += 1;
			}
		}

		if(unprocessed.size() > 1) {
			std::string unprocessedList;
			for(size_t j = 0; j < unprocessed.size(); ++j) {
				unprocessedList.append(unprocessed[j]);
				if(j + 1 < unprocessed.size()) {
					unprocessedList.append(" ");
				}
			}
			throw std::invalid_argument("More than 1 non-option provided: " + unprocessedList);
		}

		return unprocessed;
	}

	void printHelp() {
		std::cout << "Usage of program " << programName << ": " << std::endl;
		std::cout << "Run the following command: " << std::endl;
		std::cout << "./" << programName << " [options] <jsonFile>" << std::endl;
		std::cout << "where <jsonFile> is the JSON file generated from the program compile" << std::endl;

		std::cout << std::endl << "Options: " << std::endl;
		for(size_t i = 0; i < options.size(); ++i) {
			for(size_t j = 0; j < options[i].aliases.size(); ++j) {
				std::string name = options[i].aliases[j];
				if(name.size() == 1) {
					std::cout << "-" << name;
					if(options[i].hasParam) {
						std::cout << " <value>";
					}
					std::cout << std::endl;
				}
				else {
					std::cout << "--" << name;
					if(options[i].hasParam) {
						std::cout << "=<value>";
					}
					std::cout << std::endl;
				}
			}
			std::cout << options[i].description << std::endl;
			
			if(options[i].hasParam) {
				if(options[i].value.size() == 0) {
					std::cout << "Default value: <NONE>" << std::endl;
				}
				else {
					std::cout << "Default value: " << options[i].defaultValue << std::endl;
				}
			}
			std::cout << std::endl;
		}
	}
};

std::string convertIntegerListToBits(const std::string &input) {
	std::string ans;
	std::string decimalInteger;
	for(size_t i = 0; i < input.size(); ++i) {
		if('0' <= input[i] && input[i] <= '9') {
			decimalInteger.push_back(input[i]);
		}
		else {
			std::string bits = convertIntegerToBits(decimalInteger);
			decimalInteger.clear();

			ans.append(bits);
			ans.append("_");
		}
	}
	
	if(decimalInteger.size() > 0) {
		std::string bits = convertIntegerToBits(decimalInteger);
		ans.append(bits);
	}
		
	return ans;
}

std::string convertOutputToIntegerListString(const std::string &output) {
	std::string ans;

	std::string decimalInteger;
	for(size_t i = 0; i < output.size(); ++i) {
		if('0' <= output[i] && output[i] <= '9') {
			decimalInteger.push_back(output[i]);
		}
		else if(output[i] == '_') {
			std::string bits = convertBitStringToDecimalInteger(decimalInteger);
			ans.append(bits);
			ans.append(" ");
			decimalInteger.clear();
		}
	}
	
	if(decimalInteger.size() > 0) {
		std::string bits = convertBitStringToDecimalInteger(decimalInteger);
		ans.append(bits);
	}
	
	return ans;
}

std::string convertRaxToIntegerString(const std::string &raxContents) {
	std::string ans;

	std::string bits;
	for(size_t i = 0; i < raxContents.size(); ++i) {
		if('0' <= raxContents[i] && raxContents[i] <= '1') {
			bits.push_back(raxContents[i]);
		}
		else if(raxContents[i] == '_') {
			std::string decimalInteger = convertBitStringToDecimalInteger(bits);
			bits.clear();
			ans.append(decimalInteger);
			return ans;
		}
	}

	if(bits.size() > 0) {
		std::string decimalInteger = convertBitStringToDecimalInteger(bits);
		ans.append(decimalInteger);
		return ans;
	}

	return ans;
}

int main(const int argc, const char* argv[]) {
	// handle command-line options
	CommandLineParser parser;
	parser.programName = "simulate";
	
	parser.addOption(std::vector<std::string> {"h", "help"}, false, "", "Outputs this text. No other arguments are processed if this option is used.");
	parser.addOption(std::vector<std::string> {"i", "input"}, true, "", "String of space separated integer literals, like \"5 0 2 3\" or \"1\". Be sure to have quotations around the string. If there is no input, do not use this option. Do not use this option if you are using option \"read\" to get input from a file instead.");
	parser.addOption(std::vector<std::string> {"r", "read"}, true, "", "String of file name to read input from. File must contain space separated integer literals, and nothing else. Do not use this option if you are using option \"input\".");
	parser.addOption(std::vector<std::string> {"a", "alert"}, true, "50000", "Integer value. Every <value> steps of the multi-tape Turing Machine, a little message is printed showing how many steps have been completed. Set to 0 if no messaging is desired. I do not recommend setting it to a positive integer below 10000.");
	parser.addOption(std::vector<std::string> {"s", "save"}, true, "1000000", "Integer value. Every <value> steps of the multi-tape Turing Machine, progress is saved in the same JSON file given. Set to 0 if no saving is desired. I do not recommend setting it to a positive integer below 50000");
	parser.addOption(std::vector<std::string> {"l", "limit"}, true, "0", "Integer value. Set maximum number of steps to run for. If set to 0, then it will run until the multi-tape Turing Machine halts.");

	std::vector<std::string> unprocessed = parser.parseCommandLine(argc, argv);

	// handle help option if called
	if(parser.options[parser.findOptionIndex["help"]].value == "true") {
		parser.printHelp();
		return 0;
	}

	if(unprocessed.size() != 1) {
		throw std::invalid_argument("Please provide 1 JSON file generated from program compile to simulate.");
	}
	
	// read values from options
	int alertStep;
	try {
		alertStep = std::stoi(parser.options[parser.findOptionIndex["alert"]].value);
	}
	catch(const std::exception &e) {
		throw std::invalid_argument("Argument to --alert was not an integer: " + std::string(e.what()));
	}

	int saveStep;
	try {
		saveStep = std::stoi(parser.options[parser.findOptionIndex["save"]].value);
	} 
	catch(const std::exception &e) {
		throw std::invalid_argument("Argument to --save was not an integer: " + std::string(e.what()));
	}

	int limit;
	try {
		limit = std::stoi(parser.options[parser.findOptionIndex["limit"]].value);
	}
	catch(const std::exception &e) {
		throw std::invalid_argument("Argument to --limit was not an integer: " + std::string(e.what()));
	}

	// only thing that is not an option is the JSON file
	const std::string fileName(unprocessed[0]);
	std::ifstream file(fileName);

	if(!file.is_open()) {
		throw std::invalid_argument("JSON File " + fileName + " not found");
	}

	nlohmann::json j;
	file >> j;
	file.close();

	std::cout << "File successfully read" << std::endl;

	// construct MultiTapeTuringMachine from JSON read from file
	MultiTapeTuringMachine mttm = j.get<MultiTapeTuringMachine>();

	std::cout << "JSON to MTTM conversion successful" << std::endl;

	// set the input, whether from "input" or from an input file
	std::string input = parser.options[parser.findOptionIndex["input"]].value;
	if(input.size() == 0 && parser.options[parser.findOptionIndex["read"]].value.size() > 0) {
		std::string inputFileName = parser.options[parser.findOptionIndex["read"]].value;

		std::ifstream inputFile(inputFileName);
		if(!inputFile.is_open()) {
			throw std::invalid_argument("Input file " + inputFileName + " not found");
		}

		std::vector<int> nums;
		int num;
		while(inputFile >> num) {
			nums.push_back(num);
		}

		for(size_t i = 0; i < nums.size(); ++i) {
			input.append(std::to_string(nums[i]));
			if(i + 1 < nums.size()) {
				input.append(" ");
			}
		}
	}

	std::string inputBits;
	if(input.size() > 0) {
		inputBits = convertIntegerListToBits(input);
	}
	// only set input if you are starting from the very beginning, not if you are continuing
	if(inputBits.size() > 0 && mttm.numSteps() == 0) {
		mttm.setInput(inputBits);
	}

	// actual start simulating
	std::cout << std::endl;
	std::cout << "Begin simulating:" << std::endl;

	int debug = 0;

	while(!mttm.halted() && (limit <= 0 || mttm.numSteps() < static_cast<unsigned int>(limit))) {
		mttm.step(debug);

		if(debug) {
			std::cout << "After step " << mttm.numSteps() << std::endl;
			mttm.displayTapes();
		}

		if(alertStep > 0 && mttm.numSteps() % alertStep == 0) {
			std::cout << "Finished step " << mttm.numSteps() << std::endl;
		}

		if(saveStep > 0 && mttm.numSteps() % saveStep == 0) {
			// save file to JSON that was read
			std::ofstream outputFile(fileName);
			nlohmann::json j;
			to_json(j, mttm);
			outputFile << j.dump(4) << std::endl;
			outputFile.close();

			std::cout << "File " << fileName << " overwritten with current progress" << std::endl;
		}
	}

	std::cout << std::endl << "Final: " << std::endl;
	mttm.displayTapes();
	std::cout << std::endl;

	std::cout << mttm.numSteps() << " steps" << std::endl;
	std::cout << "halted ? " << (mttm.halted() ? "true" : "false") << std::endl;

	std::cout << "Output:" << std::endl;
	
	// output is in tape1
	std::string output = convertOutputToIntegerListString(mttm.tapeContents(1));

	std::cout << output << std::endl;

	std::cout << std::endl;
	std::cout << "Return value:" << std::endl;
	std::string rax = convertRaxToIntegerString(mttm.tapeContents(mttm.numTapes() - 1));
	std::cout << rax << std::endl;
}
